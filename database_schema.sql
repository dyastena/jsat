--
-- FILE: database_schema.sql
-- PROJECT: JSAT - Java Skill Assessment Tool
-- BACKEND: Supabase (PostgreSQL)
-- PURPOSE: Single source of truth for schema, RLS, and Auth integration.
--

-- ====================================================================
-- 1. ENUMS AND TYPES
-- ====================================================================

-- Define fixed values for question difficulty
CREATE TYPE difficulty_level AS ENUM ('Beginner','Novice','Intermediate','Advanced','Expert');
-- CREATE TYPE level_status_enum AS ENUM ('Beginner','Novice','Intermediate','Advanced','Expert');


-- ====================================================================
-- 2. CORE TABLES & RLS SETUP
-- ====================================================================

-- PROFILES: Links Supabase Auth to application roles.
CREATE TABLE profiles (
    -- PK is a FK to the built-in auth.users table
    id UUID REFERENCES auth.users NOT NULL PRIMARY KEY, 
    
    -- Role is essential for RLS and app logic. Defaults to 'candidate' on creation.
    role TEXT NOT NULL DEFAULT 'candidate' CHECK (role IN ('candidate', 'recruiter', 'admin')),
    
    -- The gatekeeper flag. FALSE until the user finalizes their role.
    is_role_finalized BOOLEAN NOT NULL DEFAULT FALSE,

    first_name TEXT,
    last_name TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Ensure RLS is enabled on all security-critical tables
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- ====================================================================
-- 3. ASSESSMENT TABLES
-- ====================================================================
-- Level Tables 
CREATE TABLE level (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Profile_id UUID REFERENCES profiles(id),
    Level_status difficulty_level ,
    Progress double precision,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
--ALTER TABLE level_status ENABLE ROW LEVEL SECURITY; -- Enable RLS for Level Status

-- QUESTIONS TABLE
CREATE TABLE question (
    Question_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Title text,
    Question TEXT NOT NULL,
    Input TEXT,
    Output TEXT,
    Category TEXT,
    Answer TEXT,
    Difficulty difficulty_level NOT NULL
);
ALTER TABLE question ENABLE ROW LEVEL SECURITY; -- Enable RLS for Questions

-- EXAMS TABLE
CREATE TABLE evaluation (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Question_id BIGINT REFERENCES Question(Question_id) NOT NULL,
    profile_id UUID REFERENCES profiles(id) NOT NULL, -- Link to the Candidate profile
    Correctness double precision,
    Line_code double precision,
    Time_taken double precision,
    Runtime double precision,
    error_made double precision,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE evaluation ENABLE ROW LEVEL SECURITY; -- Enable RLS for Exams

-- RESULTS TABLE (Must be after profiles and exams)
CREATE TABLE result (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Evaluation_id BIGINT REFERENCES Evaluation(id) NOT NULL,
    Cart_eval TEXT,
    Score double precision,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
--ALTER TABLE results ENABLE ROW LEVEL SECURITY; -- Enable RLS for Results



-- ====================================================================
-- 4. RLS POLICIES
-- ====================================================================

-- --- PROFILES POLICIES ---
-- 1. Allow authenticated user to create their own profile upon signup
CREATE POLICY "Allow public insert on own profile" ON profiles 
    FOR INSERT WITH CHECK (auth.uid() = id);

-- 2. Allow users to view their own profile
CREATE POLICY "Users can view own profile" ON profiles
    FOR SELECT USING (auth.uid() = id);

-- 3. Allow Admin/Recruiter to view all profiles
CREATE POLICY "Admin/Recruiter can view all profiles" ON profiles
    FOR SELECT USING (public.is_admin_or_recruiter());

-- 4. Allow user to update only their own profile metadata (first_name, last_name)
-- IMPORTANT: Role and is_role_finalized can only be changed via the finalize_role() RPC
CREATE POLICY "Users can update own profile metadata only" ON profiles
    FOR UPDATE USING (auth.uid() = id)
    WITH CHECK (auth.uid() = id);

-- --- RESULTS POLICIES ---
-- 1. Allow Admin/Recruiter to view all results
CREATE POLICY "Admin/Recruiter can view all results" ON results
    FOR SELECT USING (public.is_admin_or_recruiter());

-- 2. Allow Candidates to view only their own results
CREATE POLICY "Candidates can view own results" ON results
    FOR SELECT USING (auth.uid() = (SELECT profile_id FROM evaluation WHERE id = Evaluation_id) AND NOT public.is_admin_or_recruiter());

-- --- EXAMS POLICIES ---
-- 1. Allow everyone to view exams (Recruiters/Candidates need this)
CREATE POLICY "Allow all authenticated users to view exams" ON evaluation
    FOR SELECT USING (auth.role() = 'authenticated');
    
-- 2. Allow Admin/Recruiter to manage (INSERT/UPDATE/DELETE) exams
CREATE POLICY "Admin/Recruiter can manage exams" ON evaluation
    FOR ALL USING (public.is_admin_or_recruiter());

-- --- QUESTIONS POLICIES ---
-- 1. Allow all authenticated users to view questions (candidates need to see exam questions)
CREATE POLICY "Allow all authenticated users to view questions" ON question
    FOR SELECT USING (auth.role() = 'authenticated');

-- 2. Allow Admin/Recruiter to manage (INSERT/UPDATE/DELETE) questions
CREATE POLICY "Admin/Recruiter can manage questions" ON question
    FOR ALL USING (public.is_admin_or_recruiter());

-- ====================================================================
-- 5. AUTH TRIGGER & RPC
-- ====================================================================

-- Function to automatically create a profile row when a new user signs up.
-- Relies on the table's DEFAULT values for 'role' and 'is_role_finalized'.
-- Splits full_name from user metadata into first_name and last_name.
CREATE FUNCTION public.handle_new_user() 
RETURNS TRIGGER AS $$
DECLARE
  full_name TEXT;
  name_parts TEXT[];
BEGIN
  -- Extract full_name from raw_user_meta_data
  full_name := NEW.raw_user_meta_data->>'full_name';
  
  -- Split name into parts if it exists
  IF full_name IS NOT NULL AND full_name != '' THEN
    name_parts := string_to_array(trim(full_name), ' ');
    
    -- Insert profile with split names
    INSERT INTO public.profiles (id, first_name, last_name)
    VALUES (
      NEW.id,
      name_parts[1],
      CASE 
        WHEN array_length(name_parts, 1) > 1 
        THEN array_to_string(name_parts[2:array_length(name_parts, 1)], ' ')
        ELSE NULL
      END
    );
  ELSE
    -- Insert profile without names
    INSERT INTO public.profiles (id)
    VALUES (NEW.id);
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger: Call handle_new_user() after a new user is created in auth.users
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- RPC function to allow a user to finalize their role choice.
CREATE FUNCTION public.finalize_role(new_role TEXT)
RETURNS void AS $$
BEGIN
  UPDATE public.profiles
  SET
    role = new_role,
    is_role_finalized = TRUE
  WHERE id = auth.uid();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if current user is admin/recruiter (avoids RLS recursion)
CREATE FUNCTION public.is_admin_or_recruiter()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS(
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid()
    AND role IN ('admin', 'recruiter')
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION insert_result_after_evaluation()
RETURNS TRIGGER AS $$
DECLARE
    factor_count int := 0;
    total numeric := 0;
    calc_score numeric;
BEGIN
    -- Sum non-null factors
    IF NEW."Correctness" IS NOT NULL THEN
        total := total + NEW."Correctness";
        factor_count := factor_count + 1;
    END IF;
    IF NEW."Line_codes" IS NOT NULL THEN
        total := total + NEW."Line_codes";
        factor_count := factor_count + 1;
    END IF;
    IF NEW."Time_taken" IS NOT NULL THEN
        total := total + NEW."Time_taken";
        factor_count := factor_count + 1;
    END IF;
    IF NEW."Runtime" IS NOT NULL THEN
        total := total + NEW."Runtime";
        factor_count := factor_count + 1;
    END IF;
    IF NEW.error_made IS NOT NULL THEN
        total := total + NEW.error_made;
        factor_count := factor_count + 1;
    END IF;

    -- Calculate average score, capped at 10
    IF factor_count > 0 THEN
        calc_score := total / factor_count;
        IF calc_score > 10 THEN
            calc_score := 10;
        END IF;
    ELSE
        calc_score := 0;
    END IF;

    -- Insert into result, only using Evaluation_id and calculated score
    INSERT INTO public.result("Evaluation_id", "Cart_eval", "Score")
    VALUES (NEW.id, 'Pending', calc_score);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION accumulate_level_progress_after_result()
RETURNS TRIGGER AS $$
DECLARE
    profile_id uuid;
BEGIN
    -- Get the profile id from the evaluation linked to this result
    SELECT "profile_id" INTO profile_id
    FROM public.evaluation
    WHERE id = NEW."Evaluation_id";

    -- Add the new score to the existing Progress
    UPDATE public.level
    SET Progress = COALESCE(Progress,0) + NEW.Score
    WHERE profile_id = profile_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.create_level_after_profile()
RETURNS TRIGGER AS $$
BEGIN
    -- Only generate level if the new profile is a candidate
    IF NEW.role = 'candidate' THEN
        INSERT INTO public.level("Profile_id", "Progress", "Level_status")
        VALUES (NEW.id, 0, 'Beginner');
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_update_level_progress
AFTER INSERT ON public.result
FOR EACH ROW
EXECUTE FUNCTION accumulate_level_progress_after_result();


CREATE TRIGGER trg_insert_result
AFTER INSERT ON public.evaluation
FOR EACH ROW
EXECUTE FUNCTION insert_result_after_evaluation();

DROP TRIGGER IF EXISTS trg_create_level_after_profile ON public.profiles;

CREATE TRIGGER trg_create_level_after_profile
AFTER INSERT ON public.profiles
FOR EACH ROW
EXECUTE FUNCTION public.create_level_after_profile();


-- Disable RLS temporarily to allow the trigger to run (best practice)
ALTER FUNCTION public.handle_new_user() SET search_path = public, ext_http;
ALTER FUNCTION public.finalize_role(TEXT) SET search_path = public, ext_http;
