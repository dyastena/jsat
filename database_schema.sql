--
-- FILE: database_schema.sql
-- PROJECT: JSAT - Java Skill Assessment Tool
-- BACKEND: Supabase (PostgreSQL)
-- PURPOSE: Single source of truth for schema, RLS, and Auth integration.
--

-- ====================================================================
-- 1. ENUMS AND TYPES
-- ====================================================================

-- Define fixed values for question difficulty
CREATE TYPE difficulty_level AS ENUM ('Beginner','Novice','Intermediate','Advanced','Expert');
-- CREATE TYPE level_status_enum AS ENUM ('Beginner','Novice','Intermediate','Advanced','Expert');


-- ====================================================================
-- 2. CORE TABLES & RLS SETUP
-- ====================================================================

-- PROFILES: Links Supabase Auth to application roles.
CREATE TABLE profiles (
    -- PK is a FK to the built-in auth.users table
    id UUID REFERENCES auth.users NOT NULL PRIMARY KEY, 
    
    -- Role is essential for RLS and app logic. Defaults to 'candidate' on creation.
    role TEXT NOT NULL DEFAULT 'candidate' CHECK (role IN ('candidate', 'recruiter', 'admin')),
    
    -- The gatekeeper flag. FALSE until the user finalizes their role.
    is_role_finalized BOOLEAN NOT NULL DEFAULT FALSE,

    first_name TEXT,
    last_name TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Ensure RLS is enabled on all security-critical tables
--ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- ====================================================================
-- 3. ASSESSMENT TABLES
-- ====================================================================
-- Level Tables
CREATE TABLE level (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    profile_id UUID REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE,
    level_status difficulty_level,
    progress double precision,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
--ALTER TABLE level_status ENABLE ROW LEVEL SECURITY; -- Enable RLS for Level Status

-- QUESTIONS TABLE
CREATE TABLE question (
    question_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title text,
    question TEXT NOT NULL,
    input TEXT,
    output TEXT,
    category TEXT,
    answer TEXT,
    difficulty difficulty_level NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
--ALTER TABLE question ENABLE ROW LEVEL SECURITY; -- Enable RLS for Questions

-- EXAMS TABLE
CREATE TABLE evaluation (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question_id BIGINT REFERENCES question(question_id) ON UPDATE CASCADE ON DELETE CASCADE NOT NULL,
    profile_id UUID REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE NOT NULL, -- Link to the Candidate profile
    correctness double precision,
    line_code double precision,
    time_taken double precision,
    runtime double precision,
    error_made double precision,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
--ALTER TABLE evaluation ENABLE ROW LEVEL SECURITY; -- Enable RLS for Exams

-- RESULTS TABLE (Must be after profiles and exams)
CREATE TABLE result (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    evaluation_id BIGINT REFERENCES evaluation(id) ON UPDATE CASCADE ON DELETE CASCADE NOT NULL,
    cart_eval TEXT,
    score double precision,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
--ALTER TABLE results ENABLE ROW LEVEL SECURITY; -- Enable RLS for Results

-- ====================================================================
-- 4. RLS POLICIES
-- ====================================================================

-- --- PROFILES POLICIES ---
-- 1. Allow authenticated user to create their own profile upon signup
CREATE POLICY "Allow public insert on own profile" ON profiles 
    FOR INSERT WITH CHECK (auth.uid() = id);

-- 2. Allow users to view their own profile
CREATE POLICY "Users can view own profile" ON profiles
    FOR SELECT USING (auth.uid() = id);

-- 3. Allow Admin/Recruiter to view all profiles
CREATE POLICY "Admin/Recruiter can view all profiles" ON profiles
    FOR SELECT USING (public.is_admin_or_recruiter());

-- 4. Allow user to update only their own profile metadata (first_name, last_name)
-- IMPORTANT: Role and is_role_finalized can only be changed via the finalize_role() RPC
CREATE POLICY "Users can update own profile metadata only" ON profiles
    FOR UPDATE USING (auth.uid() = id)
    WITH CHECK (auth.uid() = id);

-- --- RESULTS POLICIES ---
-- 1. Allow Admin/Recruiter to view all results
CREATE POLICY "Admin/Recruiter can view all results" ON result
    FOR SELECT USING (public.is_admin_or_recruiter());

-- 2. Allow Candidates to view only their own results
CREATE POLICY "Candidates can view own results" ON result
    FOR SELECT USING (auth.uid() = (SELECT profile_id FROM evaluation WHERE id = evaluation_id) AND NOT public.is_admin_or_recruiter());

-- --- EXAMS POLICIES ---
-- 1. Allow everyone to view exams (Recruiters/Candidates need this)
CREATE POLICY "Allow all authenticated users to view exams" ON evaluation
    FOR SELECT USING (auth.role() = 'authenticated');
    
-- 2. Allow Admin/Recruiter to manage (INSERT/UPDATE/DELETE) exams
CREATE POLICY "Admin/Recruiter can manage exams" ON evaluation
    FOR ALL USING (public.is_admin_or_recruiter());

-- --- QUESTIONS POLICIES ---
-- 1. Allow all authenticated users to view questions (candidates need to see exam questions)
CREATE POLICY "Allow all authenticated users to view questions" ON question
    FOR SELECT USING (auth.role() = 'authenticated');

-- 2. Allow Admin/Recruiter to manage (INSERT/UPDATE/DELETE) questions
CREATE POLICY "Admin/Recruiter can manage questions" ON question
    FOR ALL USING (public.is_admin_or_recruiter());

-- --- LEVEL POLICIES ---
-- 1. Allow users to view their own level
CREATE POLICY "Users can view own level" ON level
    FOR SELECT USING (auth.uid() = profile_id);

-- ====================================================================
-- 5. AUTH TRIGGER & RPC
-- ====================================================================

-- Function to automatically create a profile row when a new user signs up.
-- Relies on the table's DEFAULT values for 'role' and 'is_role_finalized'.
-- Splits full_name from user metadata into first_name and last_name.
CREATE FUNCTION public.handle_new_user() 
RETURNS TRIGGER AS $$
DECLARE
  full_name TEXT;
  name_parts TEXT[];
BEGIN
  -- Extract full_name from raw_user_meta_data
  full_name := NEW.raw_user_meta_data->>'full_name';
  
  -- Split name into parts if it exists
  IF full_name IS NOT NULL AND full_name != '' THEN
    name_parts := string_to_array(trim(full_name), ' ');
    
    -- Insert profile with split names
    INSERT INTO public.profiles (id, first_name, last_name)
    VALUES (
      NEW.id,
      name_parts[1],
      CASE 
        WHEN array_length(name_parts, 1) > 1 
        THEN array_to_string(name_parts[2:array_length(name_parts, 1)], ' ')
        ELSE NULL
      END
    );
  ELSE
    -- Insert profile without names
    INSERT INTO public.profiles (id)
    VALUES (NEW.id);
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger: Call handle_new_user() after a new user is created in auth.users
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- RPC function to allow a user to finalize their role choice.
CREATE FUNCTION public.finalize_role(new_role TEXT)
RETURNS void AS $$
BEGIN
  UPDATE public.profiles
  SET
    role = new_role,
    is_role_finalized = TRUE
  WHERE id = auth.uid();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if current user is admin/recruiter (avoids RLS recursion)
CREATE FUNCTION public.is_admin_or_recruiter()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS(
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid()
    AND role IN ('admin', 'recruiter')
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION insert_result_after_evaluation()
RETURNS TRIGGER AS $$
DECLARE
    factor_count int := 0;
    total numeric := 0;
    calc_score numeric;
    avg_skill numeric := 0;
    cart_level text;
BEGIN
    -- Sum non-null factors for basic score calculation
    IF NEW.correctness IS NOT NULL THEN
        total := total + NEW.correctness;
        factor_count := factor_count + 1;
    END IF;
    IF NEW.line_code IS NOT NULL THEN
        total := total + NEW.line_code;
        factor_count := factor_count + 1;
    END IF;
    IF NEW.time_taken IS NOT NULL THEN
        total := total + NEW.time_taken;
        factor_count := factor_count + 1;
    END IF;
    IF NEW.runtime IS NOT NULL THEN
        total := total + NEW.runtime;
        factor_count := factor_count + 1;
    END IF;
    IF NEW.error_made IS NOT NULL THEN
        total := total + NEW.error_made;
        factor_count := factor_count + 1;
    END IF;

    -- Calculate average score, capped at 10
    IF factor_count > 0 THEN
        calc_score := total / factor_count;
        IF calc_score > 10 THEN
            calc_score := 10;
        END IF;
    ELSE
        calc_score := 0;
    END IF;

    -- Calculate CART skill average for classification
    -- This mimics the frontend logic: average of 5 skills (0-10 scale each)
    -- Where time and errors are inverted (less time/errors = higher score)
    DECLARE
        problem_solving numeric := 0;
        algorithm_design numeric := 0;
        code_quality numeric := 0;
        time_efficiency numeric := 0;
        error_handling numeric := 0;
        skill_count int := 0;
    BEGIN
        -- Problem Solving (accuracy)
        IF NEW.correctness IS NOT NULL THEN
            problem_solving := LEAST(10, GREATEST(0, NEW.correctness));
            skill_count := skill_count + 1;
        END IF;

        -- Algorithm Design (runtime/efficiency)
        IF NEW.runtime IS NOT NULL THEN
            algorithm_design := LEAST(10, GREATEST(0, NEW.runtime));
            skill_count := skill_count + 1;
        END IF;

        -- Code Quality (line_code/style)
        IF NEW.line_code IS NOT NULL THEN
            code_quality := LEAST(10, GREATEST(0, NEW.line_code));
            skill_count := skill_count + 1;
        END IF;

        -- Time Efficiency (inverted: less time = higher score)
        IF NEW.time_taken IS NOT NULL THEN
            time_efficiency := LEAST(10, GREATEST(0, 10 - NEW.time_taken));
            skill_count := skill_count + 1;
        END IF;

        -- Error Handling (inverted: fewer errors = higher score)
        IF NEW.error_made IS NOT NULL THEN
            error_handling := LEAST(10, GREATEST(0, 10 - NEW.error_made));
            skill_count := skill_count + 1;
        END IF;

        -- Calculate CART skill average
        IF skill_count > 0 THEN
            avg_skill := (COALESCE(problem_solving, 0) + COALESCE(algorithm_design, 0) +
                         COALESCE(code_quality, 0) + COALESCE(time_efficiency, 0) +
                         COALESCE(error_handling, 0)) / skill_count;
        END IF;

        -- Determine CART classification based on average skill (0-10 scale)
        IF avg_skill <= 2.5 THEN
            cart_level := 'NOVICE';
        ELSIF avg_skill <= 5.0 THEN
            cart_level := 'BEGINNER';
        ELSIF avg_skill <= 7.5 THEN
            cart_level := 'INTERMEDIATE';
        ELSIF avg_skill <= 9.0 THEN
            cart_level := 'ADVANCED';
        ELSE
            cart_level := 'EXPERT';
        END IF;
    END;

    -- Insert into result with calculated CART evaluation
    INSERT INTO public.result(evaluation_id, cart_eval, score)
    VALUES (NEW.id, cart_level, calc_score);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION accumulate_level_progress_after_result()
RETURNS TRIGGER AS $$
DECLARE
    user_profile_id uuid;
BEGIN
    -- Get the profile id from the evaluation linked to this result
    SELECT profile_id INTO user_profile_id
    FROM public.evaluation
    WHERE id = NEW.evaluation_id;

    -- Add the new score to the existing progress
    UPDATE public.level
    SET progress = COALESCE(progress,0) + NEW.score
    WHERE profile_id = user_profile_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.create_level_after_profile()
RETURNS TRIGGER AS $$
BEGIN
    -- Only generate level if the new profile is a candidate
    IF NEW.role = 'candidate' THEN
        INSERT INTO public.level(profile_id, progress, level_status)
        VALUES (NEW.id, 0, 'Beginner');
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_update_level_progress
AFTER INSERT ON public.result
FOR EACH ROW
EXECUTE FUNCTION accumulate_level_progress_after_result();


CREATE TRIGGER trg_insert_result
AFTER INSERT ON public.evaluation
FOR EACH ROW
EXECUTE FUNCTION insert_result_after_evaluation();

DROP TRIGGER IF EXISTS trg_create_level_after_profile ON public.profiles;

CREATE TRIGGER trg_create_level_after_profile
AFTER INSERT ON public.profiles
FOR EACH ROW
EXECUTE FUNCTION public.create_level_after_profile();

-- ====================================================================
-- 6. LEADERBOARD FUNCTION
-- ====================================================================

-- RPC function to get leaderboard data efficiently with period filtering
-- Shows accurate data based on selected filters
CREATE OR REPLACE FUNCTION get_leaderboard_data(level_filter text DEFAULT 'all', period_filter text DEFAULT 'all')
RETURNS TABLE (
    id uuid,
    rank bigint,
    first_name text,
    last_name text,
    username text,
    total_points double precision,
    current_level difficulty_level,
    accuracy_percent smallint,
    total_tests bigint
) AS $$
DECLARE
    start_date timestamp;
BEGIN
    -- Set period filter
    IF period_filter = 'today' THEN
        start_date := CURRENT_DATE;
    ELSIF period_filter = 'week' THEN
        start_date := CURRENT_DATE - INTERVAL '7 days';
    ELSIF period_filter = 'month' THEN
        start_date := CURRENT_DATE - INTERVAL '30 days';
    ELSE
        start_date := NULL; -- 'all' - no date filtering
    END IF;

    RETURN QUERY
    WITH level_data AS (
        SELECT
            l.profile_id,
            l.progress,
            l.level_status,
            ROW_NUMBER() OVER (ORDER BY l.progress DESC) as rank_num
        FROM level l
        INNER JOIN profiles p ON l.profile_id = p.id
        WHERE p.role = 'candidate'
        AND (level_filter = 'all' OR l.level_status::text = level_filter)
    ),
    user_stats AS (
        SELECT
            e.profile_id,
            COUNT(*) as test_count,
            COALESCE(AVG(NULLIF(e.correctness, 0)) * 10, 0) as avg_accuracy
        FROM evaluation e
        WHERE (start_date IS NULL OR e.created_at >= start_date)
        GROUP BY e.profile_id
    )
    SELECT
        ld.profile_id::uuid,
        ld.rank_num::bigint,
        p.first_name,
        p.last_name,
        LOWER(COALESCE(p.first_name, '') || COALESCE(p.last_name, ''))::text as username,
        ld.progress,
        ld.level_status,
        ROUND(us.avg_accuracy)::smallint as accuracy_percent,
        us.test_count::bigint as total_tests
    FROM level_data ld
    INNER JOIN profiles p ON ld.profile_id = p.id
    LEFT JOIN user_stats us ON ld.profile_id = us.profile_id
    ORDER BY ld.rank_num;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;




-- Disable RLS temporarily to allow the trigger to run (best practice)
ALTER FUNCTION public.handle_new_user() SET search_path = public, ext_http;
ALTER FUNCTION public.finalize_role(TEXT) SET search_path = public, ext_http;
ALTER FUNCTION get_leaderboard_data(text, text) SET search_path = public, ext_http;
